<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.9.2.1">
<title>Grouped dates</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/css/default.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/css/article.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/css/copy-button.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/css/heading-anchor.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/css/pages.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/css/site.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/css/callout.min.css">
<link rel="stylesheet" href="assets/tweaks.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/css/prism-xcode.min.css">
</head>
<body>
<nav><p><a href="index.html">Home</a>
<a href="manual.html">Manual</a>
<a href="news.html">News</a>
<a href="vignette.html">Vignette</a></p></nav>
<div class="frontmatter">
<div class="title"><h1>Grouped dates</h1></div>
</div>
<div class="body">
<div id="TOC">
<ul>
<li><a href="#sec:introduction">Introduction</a></li>
<li><a href="#yearweek">Week groupings</a></li>
<li><a href="#period">Period grouping</a></li>
<li><a href="#yearxxx">yearmonth, yearquarter and year</a></li>
<li><a href="#month">month</a></li>
<li><a href="#sec:methods-and-other-functionality">Methods and other functionality</a></li>
<li><a href="#sec:acknowledgements">Acknowledgements</a></li>
</ul>
</div>
<h2 id="sec:introduction">Introduction</h2>
<p>The goal of grates is to make it easy to group dates across a range of different
time intervals. It defines a collection of classes and associated methods that,
together, formalise the concept of grouped dates and are intuitive to use.
Currently there are classes implemented for <a href="#yearweek">year-week</a>,
<a href="#yearxxx">year-month</a>, <a href="#yearxxx">year-quarter</a> and <a href="#yearxxx">yearly</a> groupings
as well as for more flexible groupings across <a href="#period">days</a> and
<a href="#month">months</a>.</p>
<p>To illustrate are examples we use data on a simulated outbreak of Ebola Virus
Disease from the <a href="https://cran.r-project.org/package=outbreaks">outbreaks</a>
package. For our purposes we are not concerned with analysing the data, instead
we simply use the <strong>date_of_infection</strong> to help illustrate grates functionality.
To start, let us first look at the daily data.</p>
<pre><code class="language-r">library(grates)
library(outbreaks)
library(ggplot2)

# Pull out the date of infection
x &lt;- ebola_sim_clean$linelist$date_of_infection

# Calculate the daily incidence totals (ignoring missing values)
daily &lt;- aggregate(list(cases = x), by = list(date = x), FUN = length)

# Add explicit zeros for days which aren't present
range &lt;- seq.Date(min(daily$date), max(daily$date), by  = &quot;day&quot;)
daily &lt;- merge(data.frame(date = range), daily, by = &quot;date&quot;, all.x = TRUE)
daily &lt;- within(daily, cases[is.na(cases)] &lt;- 0)

# plot the resulting output
ggplot(daily, aes(date, cases)) + geom_col(width = 1) + theme_bw()
</code></pre>
<p><img src="vignette__files/chunk-2-1.png" alt="&gt;" /></p>
<h2 id="yearweek">Week groupings</h2>
<p>One of the more common date groupings is to a weekly level and grates defines
three classes for users to work with, <code>&lt;grates_isoweek&gt;</code>, <code>&lt;grates_epiweek&gt;</code> and
the <code>&lt;grates_yearweek&gt;</code>.</p>
<p>The most general of these is the <code>&lt;grates_yearweek&gt;</code> class. When creating a
general yearweek object, users must specify an associated <code>firstday</code> of the
week. This is a value from 1 to 7 representing Monday through Sunday. These
objects can be constructed directly via the <code>yearweek()</code> or with the coercion
function, <code>as_yearweek()</code>.</p>
<div class="callout-note">
<p>Internally, yearweek objects are stored as the number of weeks (starting at 0)
from the date of the <code>firstday</code> nearest the Unix Epoch (1970-01-01). Put more
simply, the number of seven day periods from:</p>
<ul>
<li>1969-12-29 for <code>firstday</code> equal to 1 (Monday)</li>
<li>1969-12-30 for <code>firstday</code> equal to 2 (Tuesday)</li>
<li>1969-12-31 for <code>firstday</code> equal to 3 (Wednesday)</li>
<li>1970-01-01 for <code>firstday</code> equal to 4 (Thursday)</li>
<li>1970-01-02 for <code>firstday</code> equal to 5 (Friday)</li>
<li>1970-01-03 for <code>firstday</code> equal to 6 (Saturday)</li>
<li>1970-01-04 for <code>firstday</code> equal to 7 (Sunday)</li>
</ul>
<p>We use this anchoring around the Unix Epoch as it allows for very efficient
conversion to, and from, date objects in which themselves anchor on 1970-01-01.</p>
<p>That said, most users should not need to consider this internal representation
and should be able to use grates blissfully unaware.</p>
</div>
<p><code>&lt;grates_isoweek&gt;</code> objects are used to represent ISO week dates as defined in
<a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. To expand further, it is
easiest to quote from Wikipedia<sup class="footnote-ref"><a href="#fn-1" id="fnref-1" data-footnote-ref>1</a></sup></p>
<blockquote>
<p>ISO weeks start with Monday and end on Sunday. Each week’s year is the
Gregorian year in which the Thursday falls. The first week of the year, hence,
always contains 4 January. ISO week year numbering therefore usually
deviates by 1 from the Gregorian for some days close to 1 January.</p>
</blockquote>
<p>Functionally, a <code>&lt;grates_isoweek&gt;</code> is equivalent to a <code>&lt;grates_yearweek&gt;</code> object
with an associated <code>firstday</code> value of 1 (Monday).</p>
<p><code>&lt;grates_epiweek&gt;</code> objects are similar but instead of starting on a Monday, they
start on a Sunday. They have been commonly used by the CDC in America and are
sometimes called CDC weeks. Functionally they are equivalent to a
<code>&lt;grates_yearweek&gt;</code> object with an associated <code>firstday</code> value of 7 (Sunday).</p>
<p>Continuing with the Ebola data from earlier we can now calculate weekly case
counts:</p>
<pre><code class="language-r"># calculate the total number for across each week
week_dat &lt;- with(daily,
    aggregate(
        list(cases = cases),
        by = list(week = as_isoweek(date)),
        FUN = sum
    )
)

head(week_dat)
</code></pre>
<pre><code>#&gt;       week cases
#&gt; 1 2014-W12     1
#&gt; 2 2014-W13     0
#&gt; 3 2014-W14     0
#&gt; 4 2014-W15     1
#&gt; 5 2014-W16     1
#&gt; 6 2014-W17     4
</code></pre>
<pre><code class="language-r"># plot the output
(week_plot &lt;-
    ggplot(week_dat, aes(week, cases)) +
    geom_col(width = 1, colour = &quot;white&quot;) +
    theme_bw())
</code></pre>
<p><img src="vignette__files/chunk-3-1.png" alt="&gt;" /></p>
<p>To assist in formatting plots of grates objects we also provides x-axis scales
that can be to extend the output from
<a href="https://cran.r-project.org/package=ggplot2">ggplot2</a> output. For example, if
we prefer non-centralised Date labels we can pass an explicit <code>format</code> argument
to the associated scale</p>
<pre><code class="language-r">week_plot + scale_x_grates_epiweek(format = &quot;%Y-%m-%d&quot;)
</code></pre>
<p><img src="vignette__files/chunk-4-1.png" alt="&gt;" /></p>
<h2 id="period">Period grouping</h2>
<p><code>&lt;grates_period&gt;</code> objects represent groupings of <code>n</code> consecutive days calculated
relative to an <code>offset</code>. It is useful for when you wish to group an arbitrary
number of dates together (e.g. 10 days).</p>
<div class="callout-note">
<p>Internally <code>&lt;grates_period&gt;</code> objects are stored as the integer number, starting
at 0, of periods since the Unix Epoch (1970-01-01) and a specified offset. Here
periods are taken to mean groupings of <code>n</code> consecutive days. For storage and
calculation purposes, <code>offset</code> is scaled relative to <code>n</code>, that is
<code>offset &lt;- offset %% n</code> and values of stored relative to this scaled offset.</p>
</div>
<p>Like yearweek objects, a period object is easily created with the <code>as_period()</code>
coercion function. <code>as_period()</code> takes 3 arguments; <code>x</code>, the vector you wish to
group, <code>n</code>, the integer number of days you wish to group, and <code>offset</code>, the
value you wish to start counting groups from relative to the Unix Epoch. For
convenience, <code>offset</code> can be given as a date you want periods to be relative to
(internally this date is converted to integer). For both Date and POSIXt objects
<code>offset</code> defaults to the minimum value of the input <code>x</code>.</p>
<p>In the example below we aggregate by 14 day periods offset from the earliest
case:</p>
<pre><code class="language-r">period_dat &lt;- with(daily,
    aggregate(
        list(cases = cases),
        by = list(period = as_period(date, n = 14, offset = min(date))),
        FUN = sum
    )
)

head(period_dat)
</code></pre>
<pre><code>#&gt;                     period cases
#&gt; 1 2014-03-19 to 2014-04-01     1
#&gt; 2 2014-04-02 to 2014-04-15     1
#&gt; 3 2014-04-16 to 2014-04-29     5
#&gt; 4 2014-04-30 to 2014-05-13    22
#&gt; 5 2014-05-14 to 2014-05-27    28
#&gt; 6 2014-05-28 to 2014-06-10    31
</code></pre>
<pre><code class="language-r">ggplot(period_dat, aes(period, cases)) +
    geom_col(width = 1, colour = &quot;white&quot;) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    xlab(&quot;&quot;)
</code></pre>
<p><img src="vignette__files/chunk-5-1.png" alt="&gt;" /></p>
<h2 id="yearxxx">yearmonth, yearquarter and year</h2>
<p>Unsurprisingly, <code>&lt;grates_yearmonth&gt;</code>, <code>&lt;grates_yearquarter&gt;</code> and <code>&lt;grates_year&gt;</code>
represent Year-month, year-quarter and year groupings. Little more needs to be
said so let’s jump straight to some examples.</p>
<div class="callout-note">
<p>These objects are stored as the integer number of months/quarters/years
(starting at 0) since the Unix Epoch (1970-01-01). To convert efficiently
between dates and months relative to the UNIX Epoch we used an algorithm based
on the approach of Davis Vaughan in the unreleased
<a href="https://github.com/DavisVaughan/datea/">datea</a> package.</p>
</div>
<pre><code class="language-r">(month_dat &lt;- with(daily,
    aggregate(
        list(cases = cases),
        by = list(month = as_yearmonth(date)),
        FUN = sum
    )
))
</code></pre>
<pre><code>#&gt;       month cases
#&gt; 1  2014-Mar     1
#&gt; 2  2014-Apr     6
#&gt; 3  2014-May    57
#&gt; 4  2014-Jun    80
#&gt; 5  2014-Jul   183
#&gt; 6  2014-Aug   453
#&gt; 7  2014-Sep   813
#&gt; 8  2014-Oct   719
#&gt; 9  2014-Nov   448
#&gt; 10 2014-Dec   307
#&gt; 11 2015-Jan   251
#&gt; 12 2015-Feb   199
#&gt; 13 2015-Mar   152
#&gt; 14 2015-Apr    73
</code></pre>
<pre><code class="language-r">(month_plot &lt;-
    ggplot(month_dat, aes(month, cases)) +
    geom_col(width = 1, colour = &quot;white&quot;) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    xlab(&quot;&quot;))
</code></pre>
<p><img src="vignette__files/chunk-6-1.png" alt="&gt;" /></p>
<p>Again we can have non-centred date labels by applying the associated scale with
the desired format.</p>
<pre><code class="language-r">month_plot + scale_x_grates_yearmonth(format = &quot;%Y-%m-%d&quot;)
</code></pre>
<p><img src="vignette__files/chunk-7-1.png" alt="&gt;" /></p>
<p>yearquarter works similarly</p>
<pre><code class="language-r">(quarter_dat &lt;- with(daily,
    aggregate(
        list(cases = cases),
        by = list(quarter = as_yearquarter(date)),
        FUN = sum
    )
))
</code></pre>
<pre><code>#&gt;   quarter cases
#&gt; 1 2014-Q1     1
#&gt; 2 2014-Q2   143
#&gt; 3 2014-Q3  1449
#&gt; 4 2014-Q4  1474
#&gt; 5 2015-Q1   602
#&gt; 6 2015-Q2    73
</code></pre>
<pre><code class="language-r">ggplot(quarter_dat, aes(quarter, cases)) +
    geom_col(width = 1, colour = &quot;white&quot;) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    xlab(&quot;&quot;)
</code></pre>
<p><img src="vignette__files/chunk-8-1.png" alt="&gt;" /></p>
<p>As does year</p>
<pre><code class="language-r">(year_dat &lt;- with(daily,
    aggregate(
        list(cases = cases),
        by = list(year = as_year(date)),
        FUN = sum
    )
))
</code></pre>
<pre><code>#&gt;   year cases
#&gt; 1 2014  3067
#&gt; 2 2015   675
</code></pre>
<pre><code class="language-r">ggplot(year_dat, aes(year, cases)) +
    geom_col(width = 1, colour = &quot;white&quot;) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    xlab(&quot;&quot;)
</code></pre>
<p><img src="vignette__files/chunk-9-1.png" alt="&gt;" /></p>
<h2 id="month">month</h2>
<p>Month objects are groupings of ‘n consecutive months’ stored relative to the
Unix Epoch. More precisely, <code>grates_month</code> objects are stored as the integer
number (starting at 0), of n-month groups since the Unix Epoch (1970-01-01).
This fixed anchoring does make them a little unwieldy but I find they can be
useful for bimonthly data.</p>
<pre><code class="language-r"># calculate the bimonthly number of cases
(bimonth_dat &lt;- with(daily,
    aggregate(
        list(cases = cases),
        by = list(group = as_month(date, n = 2)),
        FUN = sum
    )
))
</code></pre>
<pre><code>#&gt;                  group cases
#&gt; 1 2014-Mar to 2014-Apr     7
#&gt; 2 2014-May to 2014-Jun   137
#&gt; 3 2014-Jul to 2014-Aug   636
#&gt; 4 2014-Sep to 2014-Oct  1532
#&gt; 5 2014-Nov to 2014-Dec   755
#&gt; 6 2015-Jan to 2015-Feb   450
#&gt; 7 2015-Mar to 2015-Apr   225
</code></pre>
<pre><code class="language-r"># by default lower date bounds are used for the x axis
(bimonth_plot &lt;-
    ggplot(bimonth_dat, aes(group, cases)) +
    geom_col(width = 1, colour = &quot;white&quot;) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    xlab(&quot;&quot;))
</code></pre>
<p><img src="vignette__files/chunk-10-1.png" alt="&gt;" /></p>
<p>Note that the default plotting behaviour of non-centred date labels is different
to that of the yearweek, yearmonth, yearquarter and year scales where labels are
centred by default. To obtain centred labels you must explicitly set the format
to NULL in the scale:</p>
<pre><code class="language-r">bimonth_plot + scale_x_grates_month(format = NULL, n = 2L)
</code></pre>
<p><img src="vignette__files/chunk-11-1.png" alt="&gt;" /></p>
<h2 id="sec:methods-and-other-functionality">Methods and other functionality</h2>
<p>For all grates objects we have added many methods and operations to ensure
logical and consistent behaviour.</p>
<pre><code class="language-r"># Choose some dates spread across a few weeks
first &lt;- as.Date(&quot;2024-12-18&quot;)
dates &lt;- seq.Date(from = first, by = &quot;5 days&quot;, length.out = 7)

# add the corresponding ISO week (see later)
dat &lt;- data.frame(date = dates, isoweek = as_isoweek(dates))
</code></pre>
<p>Some times it is useful to access both the starting dates covered by grates
objects as well as the end dates. To this end we provide functions
<code>date_start()</code> and <code>date_end()</code>:</p>
<pre><code class="language-r">with(dat, {
    weeks &lt;- unique(isoweek)
    data.frame(
        isoweek = weeks,
        start = date_start(weeks),
        end = date_end(weeks)
    )
})
</code></pre>
<pre><code>#&gt;    isoweek      start        end
#&gt; 1 2024-W51 2024-12-16 2024-12-22
#&gt; 2 2024-W52 2024-12-23 2024-12-29
#&gt; 3 2025-W01 2024-12-30 2025-01-05
#&gt; 4 2025-W02 2025-01-06 2025-01-12
#&gt; 5 2025-W03 2025-01-13 2025-01-19
</code></pre>
<p>Note that the conversion of grate objects back to dates is analogous to
<code>date_start()</code>.</p>
<pre><code class="language-r">with(dat, identical(as.Date(isoweek), date_start(isoweek)))
</code></pre>
<pre><code>#&gt; [1] TRUE
</code></pre>
<p>To find out whether a <code>grate</code> object spans a particular date we provide a
<code>%during%</code> function:</p>
<pre><code class="language-r">with(dat, {
    data.frame(
        original_date = date,
        isoweek,
        contains.2025.01.10 = as.Date(&quot;2025-01-10&quot;) %during% isoweek
    )
})
</code></pre>
<pre><code>#&gt;   original_date  isoweek contains.2025.01.10
#&gt; 1    2024-12-18 2024-W51               FALSE
#&gt; 2    2024-12-23 2024-W52               FALSE
#&gt; 3    2024-12-28 2024-W52               FALSE
#&gt; 4    2025-01-02 2025-W01               FALSE
#&gt; 5    2025-01-07 2025-W02                TRUE
#&gt; 6    2025-01-12 2025-W02                TRUE
#&gt; 7    2025-01-17 2025-W03               FALSE
</code></pre>
<p><code>min()</code>, <code>max()</code>, <code>range()</code> and <code>seq()</code> all work as you would expect</p>
<pre><code class="language-r">weeks &lt;- dat$isoweek

(minw &lt;- min(weeks))
</code></pre>
<pre><code>#&gt; &lt;grates_isoweek[1]&gt;
#&gt; [1] &quot;2024-W51&quot;
</code></pre>
<pre><code class="language-r">(maxw &lt;- max(weeks))
</code></pre>
<pre><code>#&gt; &lt;grates_isoweek[1]&gt;
#&gt; [1] &quot;2025-W03&quot;
</code></pre>
<pre><code class="language-r">(rangew &lt;- range(weeks))
</code></pre>
<pre><code>#&gt; &lt;grates_isoweek[2]&gt;
#&gt; [1] &quot;2024-W51&quot; &quot;2025-W03&quot;
</code></pre>
<pre><code class="language-r"># seq method works if both `from` and `to` are epiweeks
seq(from = minw, to = maxw, by = 6L)
</code></pre>
<pre><code>#&gt; &lt;grates_isoweek[1]&gt;
#&gt; [1] &quot;2024-W51&quot;
</code></pre>
<pre><code class="language-r"># but will error informatively if `to` is a different class
seq(from = minw, to = 999, by = 6L)
</code></pre>
<pre><code class="language-plain error">#&gt; Error in seq.grates_isoweek(from = minw, to = 999, by = 6L): `to` must be a &lt;grates_isoweek&gt; object of length 1.
</code></pre>
<p>Addition (subtraction) of whole numbers will add (subtract) the corresponding
number of weeks to (from) the object</p>
<pre><code class="language-r">(dat &lt;- transform(dat, plus4 = isoweek + 4L, minus4 = isoweek - 4L))
</code></pre>
<pre><code>#&gt;         date  isoweek    plus4   minus4
#&gt; 1 2024-12-18 2024-W51 2025-W03 2024-W47
#&gt; 2 2024-12-23 2024-W52 2025-W04 2024-W48
#&gt; 3 2024-12-28 2024-W52 2025-W04 2024-W48
#&gt; 4 2025-01-02 2025-W01 2025-W05 2024-W49
#&gt; 5 2025-01-07 2025-W02 2025-W06 2024-W50
#&gt; 6 2025-01-12 2025-W02 2025-W06 2024-W50
#&gt; 7 2025-01-17 2025-W03 2025-W07 2024-W51
</code></pre>
<p>Addition of two yearweek objects will error as the intention is unclear.</p>
<pre><code class="language-r">transform(dat, willerror = isoweek + isoweek)
</code></pre>
<pre><code class="language-plain error">#&gt; Error in Ops.grates_isoweek(isoweek, isoweek): Cannot add &lt;grates_isoweek&gt; objects to each other.
</code></pre>
<p>Subtraction of two yearweek objects gives the difference in weeks between them</p>
<pre><code class="language-r">transform(dat, difference = plus4 - minus4)
</code></pre>
<pre><code>#&gt;         date  isoweek    plus4   minus4 difference
#&gt; 1 2024-12-18 2024-W51 2025-W03 2024-W47    8 weeks
#&gt; 2 2024-12-23 2024-W52 2025-W04 2024-W48    8 weeks
#&gt; 3 2024-12-28 2024-W52 2025-W04 2024-W48    8 weeks
#&gt; 4 2025-01-02 2025-W01 2025-W05 2024-W49    8 weeks
#&gt; 5 2025-01-07 2025-W02 2025-W06 2024-W50    8 weeks
#&gt; 6 2025-01-12 2025-W02 2025-W06 2024-W50    8 weeks
#&gt; 7 2025-01-17 2025-W03 2025-W07 2024-W51    8 weeks
</code></pre>
<p>epiweek objects can be combined with themselves but not other classes
(assuming an epiweek object is the first entry).</p>
<pre><code class="language-r">c(minw, maxw)
</code></pre>
<pre><code>#&gt; &lt;grates_isoweek[2]&gt;
#&gt; [1] &quot;2024-W51&quot; &quot;2025-W03&quot;
</code></pre>
<pre><code class="language-r">identical(c(minw, maxw), rangew)
</code></pre>
<pre><code>#&gt; [1] TRUE
</code></pre>
<pre><code class="language-r">c(minw, 1L)
</code></pre>
<pre><code class="language-plain error">#&gt; Error in c.grates_isoweek(minw, 1L): Unable to combine &lt;grates_isoweek&gt; objects with other classes.
</code></pre>
<h2 id="sec:acknowledgements">Acknowledgements</h2>
<p>The underlying implementation for these objects build upon ideas of Davis
Vaughan and the unreleased <a href="https://github.com/DavisVaughan/datea/">datea</a>
package as well as those of Zhian Kamvar and the
<a href="https://cran.r-project.org/package=aweek">aweek</a> package.</p>
<section class="footnotes" data-footnotes>
<ol>
<li id="fn-1">
<p>Wikipedia contributors. (2025, January 15). ISO week date.
In Wikipedia, The Free Encyclopedia.
Retrieved 12:47, March 6, 2025,
from <a href="https://en.wikipedia.org/w/index.php?title=ISO_week_date&amp;oldid=1269568343">https://en.wikipedia.org/w/index.php?title=ISO_week_date&amp;oldid=1269568343</a>: <a href="#fnref-1" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="1" aria-label="Back to reference 1">↩</a></p>
</li>
</ol>
</section>
</div>
<footer><div class="flex-col">
<p>Developed by Tim Taylor</p>
<p>Site built with <a href="https://github.com/yihui/litedown">litedown</a> v0.9.2.1</p>
</div></footer>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/js/sidenotes.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/js/appendix.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/js/toc-highlight.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/js/copy-button.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/js/heading-anchor.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/js/pages.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/js/center-img.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.24/js/callout.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</body>
</html>

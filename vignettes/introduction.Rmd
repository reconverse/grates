---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Grouped date classes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.width = 7,
  fig.height = 5
)
```

# Overview

**grates** makes it easy to perform common date grouping operations and provides
multiple grouped date classes for users to work with including *grate_yearweek*,
*grate_yearmonth*, *grate_yearquarter*, *grate_year*, *grate_month*,
*grate_period* and *grate_int_period*.  These classes aim to formalise the idea
of a grouped date whilst also being intuitive in their use. They build upon
ideas of Davis Vaughan and the unreleased
[**datea**](https://github.com/DavisVaughan/datea/) package. 

```{r setup, message=FALSE}
library(grates)
library(ggplot2)
library(outbreaks)
library(dplyr)
```


## yearweek 
`as_yearweek()` allows you to create <grate_yearweek> objects. As arguments it
takes, `x`, the date vector you wish to group and `firstday`, the day of the
week you wish your weeks to start on; (this defaults to 1 (Monday) and can go up
to 7 (Sunday)). The first week of the year is then defined as the first week
containing 4 days in the new calendar year. This means that the calendar year
can sometimes be different to that of the `yearweek` object.

```{r yearweekdemo}
# create weekday names
wdays <- weekdays(as.Date(as_yearweek(as.Date("2020-01-01"), firstday = 1L)) + 0:6)
wdays <- setNames(1:7, wdays)

# example of how weeks vary by firstday over December and January
dates <- as.Date("2020-12-29") + 0:5
dat <- lapply(wdays, function(x) as_yearweek(dates, x))
bind_cols(dates = dates, dat)
```

We make working with `yearweek` and other grouped date objects easier by adopting
logical conventions:

```{r yearweekconventions, error=TRUE}
dates <- as.Date("2021-01-01") + 0:30
weeks <- as_yearweek(dates, firstday = 5) # firstday = 5 to match first day of year
head(weeks, 8)
str(weeks)
dat <- tibble(dates, weeks)

# addition of wholenumbers will add the corresponding number of weeks to the object
dat %>% 
  mutate(plus4 = weeks + 4)

# addition of two yearweek objects will error as it is unclear what the intention is
dat %>% 
  mutate(plus4 = weeks + weeks)

# Subtraction of wholenumbers works similarly to addition
dat %>% 
  mutate(minus4 = weeks - 4)

# Subtraction of two yearweek objects gives the difference in weeks between them
dat %>% 
  mutate(plus4 = weeks + 4, difference = plus4 - weeks)

# weeks can be combined if they have the same firstday but not otherwise
wk1 <- as_yearweek("2020-01-01")
wk2 <- as_yearweek("2021-01-01")
c(wk1, wk2)
wk3 <- as_yearweek("2020-01-01", firstday = 2)
c(wk1, wk3)
```

For each date group we also provide associated
[ggplot2](https://cran.r-project.org/package=ggplot2) scales for the x-axis:

```{r yearweekplots}
dat <- ebola_sim_clean$linelist

week_plot <- 
  dat %>%
  mutate(date = as_yearweek(date_of_infection), firstday = 7) %>% 
  count(date, name = "cases") %>% 
  na.omit() %>% 
  ggplot(aes(date, cases)) + geom_col(width = 1, colour = "white") + theme_bw() + xlab("")

week_plot
```

We can have date labels on the x_axis by utilising `scale_x_grate_yearweek`:

```{r yearweekplots2}
week_plot + scale_x_grate_yearweek(format = "%Y-%m-%d", firstday = 7)
```

## yearmonth, yearquarter and year
`as_yearmonth()`, `as_yearquarter()` and `as_year()` behave similarly to
`as_yearweek()` with the difference main being that they have no need for a
`firstday` argument:

```{r yearothers}
# create weekday names
dates <- seq(from = as.Date("2020-01-01"), to = as.Date("2021-12-01"), by = "1 month")

as_yearmonth(dates)
as_yearquarter(dates)
as_year(dates)
as_yearmonth(dates[1]) + 0:1
as_yearquarter(dates[1]) + 0:1
as_year(dates[1]) + 0:1
```

Again we provide [ggplot2](https://cran.r-project.org/package=ggplot2) scales 
for the x-axis:

```{r yearothersplots}
dat %>%
  mutate(date = as_yearmonth(date_of_infection)) %>% 
  count(date, name = "cases") %>% 
  na.omit() %>% 
  ggplot(aes(date, cases)) + geom_col(width = 1, colour = "white") + theme_bw() + xlab("")

dat %>%
  mutate(date = as_yearquarter(date_of_infection)) %>% 
  count(date, name = "cases") %>% 
  na.omit() %>% 
  ggplot(aes(date, cases)) + geom_col(width = 1, colour = "white") + theme_bw() + xlab("")

dat %>%
  mutate(date = as_year(date_of_infection)) %>% 
  count(date, name = "cases") %>% 
  na.omit() %>% 
  ggplot(aes(date, cases)) + geom_col(width = 1, colour = "white") + theme_bw() + xlab("") + scale_x_grate_year(n.breaks = 2)
```

## month
`as_month` let's you group by an arbitrary number of calendar months. The
provided scale can also be used to create a more histogram-like plot:

```{r month}
month_plot <- 
  dat %>%
  mutate(date = as_month(date_of_infection, interval = 2)) %>% 
  count(date, name = "cases") %>% 
  na.omit() %>% 
  ggplot(aes(date, cases)) + 
    geom_col(width = 2, colour = "white") +
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 45, hjust=1)) + 
    xlab("")

month_plot

month_plot + 
  scale_x_grate_month(
    date_format = "%Y-%m-%d",
    interval = 2,
    origin = min(dat$date_of_infection, na.rm = TRUE)
  )
```

## period
`as_period` allows users to group by periods of a fixed length.
As arguments it takes, `x`, the date or integer vector you wish to group,
`interval`, the length of period to group by and, finally, `origin`, an optional
value indicating where you would like to start your periods from.

```{r period}
dat %>%
  mutate(date = as_period(date_of_infection, interval = 14)) %>% 
  count(date, name = "cases") %>% 
  na.omit() %>% 
  ggplot(aes(date, cases)) + geom_col(width = 14, colour = "white") + theme_bw() + xlab("")

dat %>%
  mutate(date = as_period(date_of_infection, interval = 28)) %>% 
  count(date, name = "cases") %>% 
  na.omit() %>% 
  ggplot(aes(date, cases)) + geom_col(width = 28, colour = "white") + theme_bw() + xlab("")
```
